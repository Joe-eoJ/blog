{"meta":{"title":"Joe's Blog","subtitle":null,"description":null,"author":"Joe","url":"https://joe-eoj.github.io"},"pages":[{"title":"About","date":"2018-06-07T15:18:51.000Z","updated":"2018-06-07T15:18:51.000Z","comments":true,"path":"about/index.html","permalink":"https://joe-eoj.github.io/about/index.html","excerpt":"","text":"This is About page."},{"title":"Categories","date":"2018-06-07T04:19:50.000Z","updated":"2018-06-07T04:19:50.000Z","comments":true,"path":"categories/index.html","permalink":"https://joe-eoj.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-07T04:19:59.000Z","updated":"2018-06-07T04:19:59.000Z","comments":true,"path":"tags/index.html","permalink":"https://joe-eoj.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Unix 常用命令汇总","slug":"Unix 常用命令汇总","date":"2018-06-10T02:00:00.000Z","updated":"2018-06-17T10:03:55.000Z","comments":true,"path":"2018/06/10/Unix 常用命令汇总/","link":"","permalink":"https://joe-eoj.github.io/2018/06/10/Unix 常用命令汇总/","excerpt":"持续更新中~~","text":"持续更新中~~ 文件查找+操作按目录名称查找find [path] -type d -name &quot;directory name [suport wild characters]&quot; -[depth|mindepth|maxdepth] npath表示搜索的根路径；-type表示搜索类型：d-目录，f-文件，若不显示指明type参数，则匹配所有；-name参数可以使用模糊匹配，也可以使用-path用于按路径搜索；-depth表示某一深度，-mindepth最小深度，-maxdepth最大深度；example:123find . -type d -name 'target' #搜索当前目录下所有的名为target的文件夹find . -type -d -path '*/WEB-INF/lib' #搜索当前目录下所有WEB-INF下的lib文件夹find /data/logs -type -f -name 'biz.log*' -depth 2 #搜索/data/logs目录的grand children目录下以biz.log开头的文件 [TOP] 对查询结果的操作find result -empty -delete -delete 删除搜索到的结果，-empty 只删除查询到的空目录；find result -exec rm -r {} [\\|+] 同样是删除搜索到的结果，\\表示 one rm command per directory found，+表示 rm with multiple directories at onceexample:1find . -type d -name 'target' -exec rm -r &#123;&#125; + #删除当前目录下所有的名为target的文件夹 [TOP] 查看文件大小du -sh 查看当前目录总共占的容量，不单独列出各子项占用的容量du -sh * | sort -n 统计当前文件夹(目录)大小，并按文件大小排序du -sh filename|directory name 查看指定文件|目录的大小[TOP]","categories":[{"name":"Unix","slug":"Unix","permalink":"https://joe-eoj.github.io/categories/Unix/"}],"tags":[]},{"title":"感悟","slug":"感悟","date":"2018-06-07T02:05:42.000Z","updated":"2018-06-08T00:33:48.000Z","comments":true,"path":"2018/06/07/感悟/","link":"","permalink":"https://joe-eoj.github.io/2018/06/07/感悟/","excerpt":"距高考，已经九年了~","text":"距高考，已经九年了~ 很多事情，就像高考前的复习一样，充满了不确定性。但是只要拼尽全力，或许下一秒就有奇迹发生，或许下一秒就能改变命运，或许啥也没改变，因为相信，所以看见！~","categories":[{"name":"感悟","slug":"感悟","permalink":"https://joe-eoj.github.io/categories/感悟/"}],"tags":[]},{"title":"JVM-内存区域","slug":"JVM 内存区域","date":"2017-12-24T02:09:05.000Z","updated":"2018-06-08T00:34:11.000Z","comments":true,"path":"2017/12/24/JVM 内存区域/","link":"","permalink":"https://joe-eoj.github.io/2017/12/24/JVM 内存区域/","excerpt":"JVM对于一位Java工程师，是必须涉猎或者一定程度上熟悉的知识。试想你的程序部署在生产环境服务器上，如果哪天crash了，如果你对JVM的内部原理一无所知，那么你将是崩溃的。所以，为了尽量避免这样的灾难性事件发生，或者发生之后为了能快速定位和解决问题，我们必须了解JVM。","text":"JVM对于一位Java工程师，是必须涉猎或者一定程度上熟悉的知识。试想你的程序部署在生产环境服务器上，如果哪天crash了，如果你对JVM的内部原理一无所知，那么你将是崩溃的。所以，为了尽量避免这样的灾难性事件发生，或者发生之后为了能快速定位和解决问题，我们必须了解JVM。 今天开始，我将系统地整理和归纳JVM领域重要的 basic knowledge，也会针对特定问题做一些扩展性的探讨。目的是将自己所学的东西消化和整理，温故而知新，同时 post 出来，希望对别人也有所启发和帮助。 今天我要尝试探讨的是JVM的内存区域，包括内存区域的划分、各个内存区域的作用。 上图是基于Java SE7虚拟机规范的内存模型。其中methodarea[方法区] 和 heap[堆]是所有线程共享的数据区域，pc register[程序计数器]、java stacks[虚拟机栈]、native method stacks[本地方法栈]是线程隔离的数据区域。这五个区域构成了JVM整个运行时的数据区域，接下来我将分别介绍每个区域的作用。 pc register[程序计数器]pc register，可以看做是当前线程执行的字节码的行号指示器，字节码解释器就是通过改变它的值来选取下一条要执行的指令，我们平时常用的分支、循环、跳转、异常处理都需要依赖它。在单核计算机时代，JVM的多线程是通过线程之间的切换以分享cpu时钟来实现的，线程之间切换之后能回到正确的执行位置，也是靠它。显而易见，它肯定是线程私有的。 java stacks[虚拟机栈]java stacks描述的是方法执行时的内存模型，方法在执行时会创建一个栈帧(stack frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息【可以理解为方法执行时的meta data，栈帧具体存储的信息，可以看这篇文章】。每一个方法从执行到完成的过程，意味着栈帧从入栈到出栈的过程。 native method stack[本地方法栈]顾名思义，就是在JVM本地方法调用的时候使用的，功能跟java stacks类似。之所以将其区别开，是因为JVM对本地方法栈中的方法使用的语言、使用方式和数据格式没有强制统一的规定，JVM 的implements可以自由实现它。 heap[堆]heap是JVM内存中占用空间最大的一块，也是垃圾收集器管理的主要区域，它用于存储对象实例和数组。前面已经提到了，heap是所有线程共享的数据区域。 method area[方法区]method area 和 heap 一样，是所有线程共享的数据区域。它用于存储被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。垃圾收集器针对该区域的回收，主要是针对常量池的回收和对类型的卸载，但是回收条件相当苛刻。runtime constant pool[运行时常量池]，作为方法区的一部分，需要提一下。运行时常量池用于存储加载后Class文件中的常量池【存放编译期生成的各种字面量和符号引用】。 direct memory[直接内存]直接内存其实不是JVM运行时的内存区域，甚至不是JVM规范中定义的内存区域，它率属于本机内存。在JDK1.4中新加入了NI/O， 引入了一种基于通道(channel)和缓冲区(buffer)的I/O方式，为了避免JVM和操作系统之间数据的来回复制，可以使用Native函数库直接分配堆外内存，然后通过存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://joe-eoj.github.io/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://joe-eoj.github.io/tags/JVM/"}]}]}