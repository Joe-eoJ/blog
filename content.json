{"meta":{"title":"Joe's Blog","subtitle":null,"description":null,"author":"Joe","url":"https://joe-eoj.github.io"},"pages":[{"title":"About","date":"2018-06-07T15:18:51.000Z","updated":"2018-06-07T15:18:51.000Z","comments":true,"path":"about/index.html","permalink":"https://joe-eoj.github.io/about/index.html","excerpt":"","text":"This is About page."},{"title":"Categories","date":"2018-06-07T04:19:50.000Z","updated":"2018-06-07T04:19:50.000Z","comments":true,"path":"categories/index.html","permalink":"https://joe-eoj.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-07T04:19:59.000Z","updated":"2018-06-07T04:19:59.000Z","comments":true,"path":"tags/index.html","permalink":"https://joe-eoj.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-06-07T02:05:42.000Z","updated":"2018-06-07T15:28:55.000Z","comments":true,"path":"2018/06/07/hello-world/","link":"","permalink":"https://joe-eoj.github.io/2018/06/07/hello-world/","excerpt":"","text":"This is a test page ~","categories":[{"name":"example","slug":"example","permalink":"https://joe-eoj.github.io/categories/example/"}],"tags":[{"name":"test","slug":"test","permalink":"https://joe-eoj.github.io/tags/test/"}]},{"title":"JVM-内存区域","slug":"JVM 内存区域","date":"2017-12-24T02:09:05.000Z","updated":"2018-06-07T15:15:26.000Z","comments":true,"path":"2017/12/24/JVM 内存区域/","link":"","permalink":"https://joe-eoj.github.io/2017/12/24/JVM 内存区域/","excerpt":"JVM对于一位Java工程师，是必须涉猎或者一定程度上熟悉的知识。试想你的程序部署在生产环境服务器上，如果哪天crash了，如果你对JVM的内部原理一无所知，那么你将是崩溃的。所以，为了尽量这样的灾难性事件发生，或者发生之后为了能快速定位和解决问题，我们必须了解JVM。","text":"JVM对于一位Java工程师，是必须涉猎或者一定程度上熟悉的知识。试想你的程序部署在生产环境服务器上，如果哪天crash了，如果你对JVM的内部原理一无所知，那么你将是崩溃的。所以，为了尽量这样的灾难性事件发生，或者发生之后为了能快速定位和解决问题，我们必须了解JVM。 今天开始，我将系统地整理和归纳JVM领域重要的 basic knowledge，也会针对特定问题做一些扩展性的探讨。目的是将自己所学的东西消化和整理，温故而知新，同时 post 出来，希望对别人也有所启发和帮助。 今天我要尝试探讨的是JVM的内存区域，包括内存区域的划分、各个内存区域的作用。 上图是基于Java SE7虚拟机规范的内存模型。其中methodarea[方法区] 和 heap[堆]是所有线程共享的数据区域，pc register[程序计数器]、java stacks[虚拟机栈]、native method stacks[本地方法栈]是线程隔离的数据区域。这五个区域构成了JVM整个运行时的数据区域，接下来我将分别介绍每个区域的作用。 pc register[程序计数器]pc register，可以看做是当前线程执行的字节码的行号指示器，字节码解释器就是通过改变它的值来选取下一条要执行的指令，我们平时常用的分支、循环、跳转、异常处理都需要依赖它。在单核计算机时代，JVM的多线程是通过线程之间的切换以分享cpu时钟来实现的，线程之间切换之后能回到正确的执行位置，也是靠它。显而易见，它肯定是线程私有的。 java stacks[虚拟机栈]java stacks描述的是方法执行时的内存模型，方法在执行时会创建一个栈帧(stack frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息【可以理解为方法执行时的meta data，栈帧具体存储的信息，可以看这篇文章】。每一个方法从执行到完成的过程，意味着栈帧从入栈到出栈的过程。 native method stack[本地方法栈]顾名思义，就是在JVM本地方法调用的时候使用的，功能跟java stacks类似。之所以将其区别开，是因为JVM对本地方法栈中的方法使用的语言、使用方式和数据格式没有强制统一的规定，JVM 的implements可以自由实现它。 heap[堆]heap是JVM内存中占用空间最大的一块，也是垃圾收集器管理的主要区域，它用于存储对象实例和数组。前面已经提到了，heap是所有线程共享的数据区域。 method area[方法区]method area 和 heap 一样，是所有线程共享的数据区域。它用于存储被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。垃圾收集器针对该区域的回收，主要是针对常量池的回收和对类型的卸载，但是回收条件相当苛刻。runtime constant pool[运行时常量池]，作为方法区的一部分，需要提一下。运行时常量池用于存储加载后Class文件中的常量池【存放编译期生成的各种字面量和符号引用】。 direct memory[直接内存]直接内存其实不是JVM运行时的内存区域，甚至不是JVM规范中定义的内存区域，它率属于本机内存。在JDK1.4中新加入了NI/O， 引入了一种基于通道(channel)和缓冲区(buffer)的I/O方式，为了避免JVM和操作系统之间数据的来回复制，可以使用Native函数库直接分配堆外内存，然后通过存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://joe-eoj.github.io/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://joe-eoj.github.io/tags/JVM/"}]}]}